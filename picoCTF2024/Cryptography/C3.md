# C3
<img width="956" height="592" alt="image" src="https://github.com/user-attachments/assets/8b55d410-add9-4fab-965c-2c38dbc35cc2" />

## Objective
The objective of this challenge is to decrypt a message encrypted using a **Custom Cyclical Cipher (C3)** and recover the hidden flag.

## Description
This challenge provides a ciphertext and the source code of the custom encryption algorithm.  
The encryption process uses a non-standard alphabet and a stateful mechanism where each character depends on the previous one.

In addition, the decrypted output contains a hidden message that must be extracted following a specific positional pattern.


## Provided Encoder Code

```python
import sys
from fileinput import input

chars = ""
for line in input():
    chars += line

lookup1 = "\n \"#()*+/1:=[]abcdefghijklmnopqrstuvwxyz"
lookup2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghi jklmnopqrstuvwxyz"

out = ""
prev = 0

for char in chars:
    cur = lookup1.index(char)
    out += lookup2[(cur - prev) % 40]
    prev = cur

sys.stdout.write(out)

```


## Methodology
First, the provided encoder source code is analyzed to understand how the encryption process works.  
Two lookup tables are defined: one containing special characters and lowercase letters, and another containing uppercase and lowercase letters.

During encryption, each character is converted to an index using the first lookup table.  
This index is combined with the previous character’s index, and the result is mapped to the second lookup table using modulo arithmetic.  
Because of this, the cipher is stateful and depends on the previous character.

### Cipher and Reverse Cipher Explanation

To understand how the cipher works, characters are first mapped to numeric indices.  
For simplicity, consider the following mapping:

lookup1:  [ \n, space, ", #, (, ), *, +, /, 1, :, =, [, ], a, b, c, d, e, f, ... ]

index:      0    1    2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 ...


lookup2:  A B C D E F G H I J K L M N O P Q R S T a b c d e f g h i j k l m n o p q r s t

index:    0 1 2 3 4 5 6 7 8 9 ...


The cipher uses two values:
- `c`: the index of the current character
  
- `p`: the index of the previous character (initially `0`)

#### Encryption Process

Plaintext (lookup1):  \n  "  a  d

The encryption formula is: out = (c - p) mod 40

- First character:
  
c = lookup1.index('\n') = 0,  
 p = 0 (initial state)

out = (0 - 0) % 40 = 0 -> lookup2[0] = 'A'

- Secnod character:
  
c = lookup1.index('"') = 2,
 p = 0

out = (2 - 0) % 40 = -> 2 lookup2[2] = 'C'

- Third character:
  
c = lookup1.index('a') = 14, 
p = 2

out = (14 - 2) % 40 = 12 -> lookup2[12] = 'M


- Fourth character:
  
c = lookup1.index('d') = 17, p = 14

out = (17 - 14) % 40 = 3 -> lookup2[3] = 'D'



if we notice how the proccess works, we can state that adding the output we have got form encoding to the previous index we would get again our current index.

so the formula would be 

c = (out + p) mod 40

A simple approach of the solution would be :

```python
for char in chars:

  cipher = lookup2.index(char)
  cur = (cipher + prev) % 40
  plaintext += lookup1[cur]
  prev = cur;
```


After decrypting the full plaintext, it becomes clear that the meaningful message is hidden within the text.  
By extracting characters located at cubic positions (1³, 2³, 3³, …), the hidden message is revealed and forms the final flag.

## Python 2 vs Python 3 Considerations
The provided encoder code was originally written with Python 2 behavior in mind.  
When adapting the code to Python 3, several compatibility issues were encountered, mainly related to string handling, input processing, and indexing behavior.

To resolve these issues, **ChatGPT was used as a reference** to understand the differences between Python 2 and Python 3 and to correctly adapt the code so that the decryption logic worked as intended.

This ensured that the script executed correctly in a Python 3 environment without altering the original encryption logic.

After decrypting the full plaintext, it becomes clear that the meaningful message is hidden within the text.  
By extracting characters located at cubic positions (1³, 2³, 3³, …), the hidden message is revealed and forms the final flag

```python

ciphertext = (
    "DLSeGAGDgBNJDQJDCFSFnRBIDjgHoDFCFtHDgJpiHtGDmMAQFnRBJKkBAsTMrsPSDDnEFCFtIbEDtDCIbFCFtHTJDKerFldbFObFCFtLBFkBAAAPFnRBJGEkerFlcPgKkImHnIlATJDKbTbFOkdNnsgbnJRMFnRBNAFkBAAAbrcbTKAkOgFpOgFpOpkBAAAAAAAiClFGIPFnRBaKliCgClFGtIBAAAAAAAOgGEkImHnIl"
)

lookup1 = "\n \"#()*+/1:=[]abcdefghijklmnopqrstuvwxyz"
lookup2 = "ABCDEFGHIJKLMNOPQRSTabcdefghijklmnopqrst"




plaintext = ""
prev = 0

for char in ciphertext:
    if char not in lookup2:
        continue
    cipher = lookup2.index(char)
    cur = (cipher + prev) % 40
    plaintext += lookup1[cur]
    prev = cur


b = 1
hidden = ""

for i, ch in enumerate(plaintext):
    if i == b ** 3:
        hidden += ch
        b += 1


print(plaintext)


print(hidden)
```

## Result
By reversing the custom cipher, extracting the hidden characters, and adapting the code to Python 3, the original message and flag are successfully recovered.

## Flag

picoCTF{adlibs}

